/* Copyright (c) 2010 Justin Seyster
   Copyright (c) 2010 Ketan Dixit
   Copyright (c) 2010 Erez Zadok
   Copyright (c) 2010 Stony Brook University
   Copyright (c) 2010 The Research Foundation of SUNY

   This program is free software: you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License
   and a copy of the GCC Runtime Library Exception along with this
   program; see the files COPYING and COPYING.RUNTIME respectively.
   If not, see <http://www.gnu.org/licenses/>. */

/* aop-header.c: Functions for storing the advice function prototypes
   we have seen and later outputing those prototypes to an
   auto-generated header file. */

/* Whether we want them or not (we don't), Autoconf _insists_ on
   defining these.  Since GCC's config.h (which we must include) also
   defines them, we have to undef them here. */
#undef PACKAGE_BUGREPORT
#undef PACKAGE_NAME
#undef PACKAGE_STRING
#undef PACKAGE_TARNAME
#undef PACKAGE_VERSION

/* This is to make sure that stdio.h includes the prototype for
   fgets_unlocked, which GCC prefers over regular fgets.  */
#define _GNU_SOURCE

#include <fcntl.h>
#include <locale.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include <config.h>
#include <system.h>
#include <tree.h>
#include <hashtab.h>
#include <toplev.h>

#include "aop.h"
#include "aop-dynval.h"
#include "aop-header.h"
#include "aop-type.h"

/* The default license text for InterAspect-generated headers.  This
   license text _does not_ apply to this file, of course! */
static const char *default_license =
  "/* Though this file was auto-generated by InterAspect, it _is not_\n"
  "   bound by InterAspect's license (and copyright does not belong to\n"
  "   the InterAspect team).  If this file was provided to you by\n"
  "   somebody else, contact that person to find out its licensing terms.\n"
  "   If you generated this file, you can replace this text with your own\n"
  "   licensing terms by specifying them to aop_write_c_header(). */\n";

/* The default preamble for InterAspect-generated headers. */
static const char *default_preamble =
  "/* This header file was auto-generated by an InterAspect-based\n"
  "   plug-in.  Do not change this file: modifications will be lost and\n"
  "   may result in errors when InterAspect attempts to parse this file\n"
  "   in the future. */\n";

/* Some typedefs that InterAspect-generated headers use for
   parameters. */
static const char *header_typedefs =
  "typedef int64_t ALL_SIGNED_T;\n"
  "typedef uint_t ALL_UNSIGNED_T;\n"
  "typedef double ALL_FP_T;\n"
  "typedef void *ALL_POINTER_T;\n\n"
  "/* BEGIN PROTOTYPES */\n";

/**
 * \cond HIDDEN_SYMBOLS
 */

/* An aop_prototype struct represents the prototype of an advice
   function, including its name, return type and parameters. */
struct aop_prototype {
  /* Users should not create multiple prototypes with the same name
     but different return/parameter types, but if they do, we can
     chain them together in this list. */
  struct aop_prototype *next;

  /* True if the prototype has return type int.  False if the
     prototype has a void return type. */
  bool has_return_value;

  const char *name;

  int num_params;
  const struct aop_type *param_types[];
};
/**
 * \endcond
 */

/* This table matches function name to function prototype.  Where
   there are multiple prototypes with the same name (an error case),
   those prototypes are chained together in a linked list. */
static htab_t prototype_table = NULL;

/* This is the equality function that the hashtable uses to determine
   if a prototype entry in the table matches a key. */
static int
htab_protoype_eq (const void *table_entry, const void *key)
{
  const struct aop_prototype *prototype =
    (const struct aop_prototype *)table_entry;

  return (strcmp (prototype->name, key) == 0);
}

/* This is the equality function that the hashtable uses to determine
   if a string entry in a table matches a key. */
static int
htab_str_eq (const void *table_entry, const void *key)
{
  return (strcmp ((const char *)table_entry, (const char *)key) == 0);
}

/* Return true if a prototype has the same return value and parameters
   as a potential new prototype. */
static bool
is_compatible_prototype (struct aop_prototype *prototype,
			 bool has_return_value, int num_params,
			 const struct aop_type *param_types[])
{
  int i;

  /* The prototypes do not match if one returns a value and the other
     does not. */
  if ((prototype->has_return_value && !has_return_value) ||
      (!prototype->has_return_value && has_return_value))
    return false;

  if (prototype->num_params != num_params)
    return false;

  for (i = 0; i < num_params; i++)
    {
      if (!are_types_equal (prototype->param_types[i], param_types[i]))
	return false;
    }

  /* These prototypes match. */
  return true;
}

static void
get_param_types (va_list argp, int num_params,
		 const struct aop_type *param_types[])
{
  int i;
  enum aop_argkind kind;
  struct aop_dynval *dv;

  for (i = 0; i < num_params; i++)
    {
      kind = va_arg (argp, enum aop_argkind);
      switch (kind)
	{
	case ATA_STR_CST:
	  va_arg (argp, const char *);
	  param_types[i] = aop_t_pointer_to (aop_t_signed8 ());
	  break;
	case ATA_INT_CST:
	  va_arg (argp, int);
	  param_types[i] = aop_t_signed32 ();
	  break;
	case ATA_DOUBLE_CST:
	  va_arg (argp, double);
	  param_types[i] = aop_t_float64 ();
	  break;
	case ATA_VOIDP_CST:
	  va_arg (argp, void *);
	  param_types[i] = aop_t_all_pointer ();
	  break;
	case ATA_DYNVAL:
	  dv = va_arg (argp, struct aop_dynval *);
	  param_types[i] = dv->type;
	  break;
	default:
	  aop_assert (0);
	}
    }

  aop_assert (va_arg (argp, enum aop_argkind) == AOP_TERM_ARG);
}

/* If there is no entry in the list of advice function prototypes for
   this advice function, create one.  If a prototype already exists
   with conflicting types, issue a warning. */
void
insert_prototype (bool has_return_value, const char *name, int num_params,
		  va_list argp)
{
  size_t param_types_size;
  const struct aop_type **param_types;

  struct aop_prototype **hash_slot;
  struct aop_prototype *prototype;

  param_types_size = num_params * sizeof (const struct aop_type *);
  param_types = alloca (param_types_size);
  get_param_types (argp, num_params, param_types);

  /* Check the hash table for a prototype with this name. */
  hash_slot =
    (struct aop_prototype **)htab_find_slot (prototype_table, name, INSERT);
  if (*hash_slot != NULL)
    {
      /* We already have at least one prototype with this name.  Make
	 sure one of them is compatible. */
      while (*hash_slot != NULL)
	{
	  prototype = *hash_slot;

	  if (is_compatible_prototype (prototype, has_return_value, num_params,
				       param_types))
	    {
	      /* Found one!  Nothing else to do. */
	      return;
	    }

	  hash_slot = &prototype->next;
	}

      /* None of the prototypes we have already seen matches this one.
	 First, we issue a warning. */
      warning (0, "(InterAspect) Calls to advice function %s with different "
	       "prototypes", name);

      /* Then we fall through to the code to allocate and initialize a
	 new prototype object. */
    }

  /* Allocate the new prototype and insert it in the hash table (or in
     the linked list if we happened to find a hash table entry
     already). */
  prototype = xmalloc (sizeof (struct aop_prototype) + param_types_size);
  *hash_slot = prototype;

  prototype->next = NULL;
  prototype->has_return_value = has_return_value;
  prototype->name = xstrdup (name);
  prototype->num_params = num_params;
  memcpy (prototype->param_types, param_types, param_types_size);
}

/* Returns true if symbol is a valid C preprocessor symbol. */
static bool
is_valid_c_symbol (const char *symbol)
{
  /* No, the empty string is not a valid symbol. */
  if (*symbol == '\0')
    return false;

  /* C symbols may contain numerals, but they may not begin with
     one. */
  if (*symbol >= '0' && *symbol <= '9')
    return false;

  for (; *symbol != '\0'; symbol++)
    {
      if (*symbol >= '0' && *symbol <= '9')
	continue;
      else if (*symbol >= 'a' && *symbol <= 'z')
	continue;
      else if (*symbol >= 'A' && *symbol <= 'Z')
	continue;
      else if (*symbol == '_')
	continue;
      else
	return false;  /* Invalid character. */
    }

  return true;  /* No invalid characters. */
}

/* A buffer for fgets to read lines into and for write_protoype to
   write lines into. . */
static char line[2048];

/* Read an auto-generated header file to find the prototypes already
   in it.  These prototypes are output as strings to a hash table.
   Returns 0 on success or a UNIX error code on failure. */
static int
read_header_prototypes (FILE *header, htab_t prototype_strings)
{
  /* Read until we get to the beginning of the list of prototypes. */
  while (fgets (line, sizeof (line), header) != NULL)
    {
      if (strstr (line, "BEGIN PROTOTYPES") != NULL)
	break;  /* Found it. */
    }

  if (feof (header))
    return 0;  /* There are no prototypes in this header. */
  else if  (ferror (header))
    return errno;

  /* Now read each line and check if it is a prototype. */
  while (fgets (line, sizeof (line), header) != NULL)
    {
      const char **hash_slot;

      /* TODO: This is better suited to a regex match. */
      if (line[0] == '\0')
	continue;
      else if (line[0] == '\n')
	continue;
      else if (line[0] == '#')
	continue;

      /* Found a prototype!  Insert it in the hash table. */
      hash_slot =
	(const char **)htab_find_slot (prototype_strings, line, INSERT);
      if (*hash_slot == NULL)
	*hash_slot = xstrdup (line);
    }

  if (feof (header))
    return 0;  /* Success. */
  else if  (ferror (header))
    return errno;
  else
    aop_assert (0);  /* Why did fgets return NULL, then? */
}

/* Quick-and-dirty printf variant that will output to a buffer without
   overrunning it. */
#define BUF_PRINTF(format, ...)				\
  do {							\
    int bytes;						\
    bytes = snprintf (out, size, format, __VA_ARGS__);	\
    out += bytes;					\
    size -= bytes;					\
  } while (0)

/* Format a single aop_prototype as a string and put that string in
   the hash table of protoype strings.  This is used as a callback for
   htab_traverse. */
static int
write_prototype (void **table_entry, void *info)
{
  int i;
  char *out;
  const char *return_type;
  size_t size;
  struct aop_prototype *prototype = *table_entry;
  htab_t prototype_strings = (htab_t)info;
  const char **hash_slot;

  out = line;
  size = sizeof (line);

  return_type = prototype->has_return_value ? "int" : "void";
  BUF_PRINTF ("%s %s(", return_type, prototype->name);

  /* Print each of the types. */
  for (i = 0; i < prototype->num_params; i++)
    {
      const struct aop_type *param_type = prototype->param_types[i];

      {
	int bytes;
	bytes = format_c_type (param_type, size, out);
	out += bytes;
	size -= bytes;
      }

      /* Add a comma separator if there are more parameters to
	 list. */
      if (i < prototype->num_params - 1)
	BUF_PRINTF("%s", ", ");
    }

  BUF_PRINTF ("%s", ");\n");

  /* Oops!  This prototype was too long. */
  if (size <= 0)
    sprintf (line, "#warning Overlong protoype.\n");

  /* Save this prototype to the hash table. */
  hash_slot = (const char **)htab_find_slot (prototype_strings, line, INSERT);
  if (*hash_slot == NULL)
      *hash_slot = xstrdup (line);

  return 1;  /* Continue the traversal. */
}

#undef BUF_PRINTF

/* Place a string from the hash table and place it in an array.  This
   is used as a callback for htab_traverse. */
static int
dump_prototype (void **table_entry, void *info)
{
  const char *prototype = (const char *)*table_entry;

  /* This is a pointer to an array of strings. */
  const char ***iterator = (const char ***)info;

  (*iterator)[0] = prototype;
  (*iterator)++;

  return 1;  /* Continue the traversal. */
}

/* Comparator for quicksort. */
static int
qsort_strcmp (const void *a, const void *b)
{
  char *const *const str_a = a;
  char *const *const str_b = b;
  return strcmp (*str_a, *str_b);
}

/* Write the actual header contents to an already opened file.  The
   prototype_strings table contains prototypes that were in the
   original header (which we are overwriting) formatted as strings.
   These original prototypes will also appear in the output.  Returns
   0 on success or a UNIX error on failure. */
static int
write_header_contents (FILE *header, const char *guard, const char *license,
		       const char *preamble, htab_t prototype_strings)
{
  int i;
  int size;
  const char **prototype_array;

  /* Used by dump_prototype to iterate prototype_array. */
  const char **iterator;

  /* Print the guard. */
  if (guard != NULL)
    {
      size = fprintf (header, "#ifndef %s\n#define %s\n\n", guard, guard);
      if (size < 0)
	return EIO;
    }

  /* Print the license and preamble text and header typedefs. */
  if (license == NULL)
    license = default_license;
  if (preamble == NULL)
    preamble = default_preamble;

  size = fprintf (header, "%s\n%s\n%s\n", license, preamble, header_typedefs);
  if (size < 0)
    return EIO;

  /* Format the prototypes into strings. */
  htab_traverse (prototype_table, write_prototype, prototype_strings);
  if (ferror (header))
    return EIO;

  /* Pull all the formatted prototypes into an array. */
  prototype_array = xmalloc (sizeof (const char *) *
			     htab_elements (prototype_strings));
  iterator = prototype_array;
  htab_traverse (prototype_strings, dump_prototype, &iterator);

  /* Sort the array.  This is so that header files are identical, no
     matter the order of compilation. */
  qsort (prototype_array, htab_elements (prototype_strings),
	 sizeof (const char *), qsort_strcmp);

  for (i = 0 ; i < htab_elements (prototype_strings); i++)
    {
      size = fprintf (header, "%s", prototype_array[i]);
      if (size < 0)
	{
	  free (prototype_array);
	  return EIO;
	}
    }

  free (prototype_array);

  /* Close the guard. */
  if (guard != NULL)
    {
      size = fprintf (header, "\n#endif\n");
      if (size < 0)
	return EIO;
    }

  return 0; /* Success. */
}

/**
 * \defgroup c_header Automatic C Header Files
 * \{
 */

/**
 * Add prototypes for every advice function added with
 * aop_insert_advice().  If the specified header file already exists,
 * aop_write_c_header() reads it and adds only prototypes that do not
 * already appear in the file.  InterAspect uses advisory file locks
 * to control access to a header file, so it is ok for parallel
 * compiles to write to the same header (so long as your system
 * supports advisory locks).
 *
 * Note that generated header files <i>are not</i> bound to
 * InterAspect's license.  If you choose to distribute an
 * InterAspect-generated header, you may use any terms you wish.
 *
 * \param filename The name of the header file to generate.  The file
 * will be created if it does not exist.  May not be NULL.
 * \param guard A valid C preprocessor symbol to use for the header
 * file's ifdef guard.  If this is NULL, the header file will not have
 * an ifdef guard.  Guard symbols are typically of the form
 * _FILENAME_H_.
 * \param license Your choice of license text, if you wish to
 * distribute the generated header under a license.  Your text should
 * be in the form of a C comment.  If this is NULL, the header will
 * begin with the default license text, which indicates that the file
 * is <i>not bound</i> by the terms of any license.  Pass the empty
 * string if you do not wish to include any license text.
 * \param preamble Any other preamble text you wish to begin the
 * header with.  This text should be valid C/C++ comments or code.  If
 * this is NULL, the header preamble will be a general comment about
 * InterAspect-generated headers.
 * \return On success, the return value is 0.  On failure, the return
 * value is one of the UNIX error codes from errno.h.
 * - EINVAL: The specified filename is NULL, or the specified guard is
 *   not a valid C preprocessor symbol.
 * - Any of the possible errno results from the open(2) function.
 * - Any of the possible errno results from the write(2) function.
 * - Any of the possilbe errno results from the fcntl(2) function.
 * Failure will also set errno to the returned error value, so you can
 * use the perror(3) function to print a user-readable error message.
 */
int
aop_write_c_header (const char *filename, const char *guard,
		    const char *license, const char *preamble)
{
  int result = 0;
  int fcntl_res;
  FILE *header;
  struct flock header_lock;

  /* This table stores each prototype as a string, as it should be
     written out to the header file.  Using a hash table makes it easy
     to avoid duplicate lines. */
  htab_t prototype_strings;

  if (filename == NULL)
    return EINVAL;

  if (guard != NULL && !is_valid_c_symbol (guard))
    return EINVAL;

  prototype_strings = htab_create_alloc (16, htab_hash_string, htab_str_eq,
					 NULL, xcalloc, free);

  /* Create the file if it doesn't exist.  Open _without_ truncating
     if it does. */
  if ((header = fopen (filename, "a+")) == NULL)
    {
      result = errno;
      goto out_free;
    }

  /* Lock the file.  We use fcntl over flock because it works over
     network file systems (on some operating systems). */
  header_lock.l_start = 0;
  header_lock.l_len = 0;
  header_lock.l_pid = getpid();
  header_lock.l_type = F_WRLCK;
  header_lock.l_whence = SEEK_SET;
  while ((fcntl_res = fcntl (fileno (header), F_SETLKW, &header_lock)) == -1)
    {
      /* A bad file descriptor means a bug in InterAsepct.
	 InterAspect never attempts to take more than one lock, so a
	 deadlock also means some kind of bug (probably in
	 InterAspect). */
      aop_assert (errno != EBADF && errno != EDEADLK);

      if (errno == EINVAL)
	{
	  verbatim ("(InterAspect) %s: Locking not supported for generated "
		    "header.  Parallel compiles (for example with make -j) "
		    "may corrupt this header file.", filename);

	  /* Give up on trying to take a lock. */
	  break;
	}
      else if (errno != EINTR)
	{
	  /* Some other I/O error. */
	  result = errno;
	  goto out_close;
	}

      /* errno was EINTR, meaning we got interrupted while we were
	 trying to take the lock.  So try again! */
      aop_assert (errno == EINTR);
    }

  /* Get the prototypes that are already in the header file. */
  read_header_prototypes (header, prototype_strings);

  /* Now erase everything in the file so we can rewrite it. */
  if (ftruncate (fileno (header), 0) != 0)
    {
      aop_assert (errno != EBADF);

      result = errno;
      goto out_unlock;
    }

  result = write_header_contents (header, guard, license, preamble,
				  prototype_strings);
  if (result != 0)
    goto out_unlock;

  /* Flush any buffered I/O. */
  if (fflush(header) != 0)
    {
      aop_assert (errno != EBADF);
      result = errno;
      goto out_unlock;
    }

  /* Do our best to make sure that the header sees the disk.  We don't
     even check the error code because what are we going to do if
     there is an error anyway? */
  (void)fsync (fileno (header));

 out_unlock:
  /* Release the file lock.  Again, there's nothing to be done about
     errors. */
  header_lock.l_type = F_UNLCK;
  (void)fcntl(fileno (header), F_SETLK, &header_lock);

 out_close:
  if (fclose (header) != 0)
    {
      aop_assert (errno != EBADF);

      /* If we already encountered an error, report the earlier error
	 rather than this one. */
      if (result != 0)
	result = errno;
    }

 out_free:
  htab_delete (prototype_strings);

  errno = result;
  return result;
}

/* Close Doxygen defgroup block. */
/**
 * \}
 */

void
init_prototype_table()
{
  prototype_table = htab_create_alloc (16, htab_hash_string, htab_protoype_eq,
				       NULL, xcalloc, free);
}

void
free_prototype_table()
{
  /* TODO: Free the contents as well. */
  htab_delete (prototype_table);
}
